"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1617],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),l=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=l(n),m=r,h=u["".concat(p,".").concat(m)]||u[m]||c[m]||i;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},918:function(e,t,n){n.r(t),n.d(t,{contentTitle:function(){return p},default:function(){return u},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return d}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],s={id:"PRC721_contract",title:"PRC-721",sidebar_label:"PRC-721"},p=void 0,l={unversionedId:"PRC721_contract",id:"PRC721_contract",isDocsHomePage:!1,title:"PRC-721",description:"PRC-721 Contract",source:"@site/../docs/prc-721.md",sourceDirName:".",slug:"/PRC721_contract",permalink:"/docs/PRC721_contract",editUrl:"https://github.com/PlatONnetwork/docs/tree/master/docs/prc-721.md",version:"current",frontMatter:{id:"PRC721_contract",title:"PRC-721",sidebar_label:"PRC-721"},sidebar:"docs",previous:{title:"PRC-20",permalink:"/docs/PRC20_contract"},next:{title:"PlatScan",permalink:"/docs/PlatON_BlockChain_Browser"}},d=[{value:"PRC-721 Contract",id:"prc-721-contract",children:[{value:"Protocol Standards",id:"protocol-standards",children:[]},{value:"Example",id:"example",children:[]},{value:"View",id:"view",children:[]},{value:"Deploy",id:"deploy",children:[]}]},{value:"Invoking functions",id:"invoking-functions",children:[{value:"Upload Metadata to IPFS network",id:"upload-metadata-to-ipfs-network",children:[]}]}],c={toc:d};function u(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"prc-721-contract"},"PRC-721 Contract"),(0,i.kt)("p",null,"PRC-721 is a standard interface for issuing non-fungible tokens (NFT) on the PlatON network and is fully compatible with ",(0,i.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-721"},"ERC-721"),"."),(0,i.kt)("h3",{id:"protocol-standards"},"Protocol Standards"),(0,i.kt)("p",null,"Each PRC-721-compliant smart contract must implement the PRC721 and PRC165 interfaces, and can implement other extended interfaces according to business needs."),(0,i.kt)("h4",{id:"prc-721--prc-165-interface"},"PRC-721 & PRC-165 Interface"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Solidity"},"interface PRC721 /* is PRC165 */ {\n    //events\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    //required\n    function balanceOf(address _owner) external view returns (uint256);\n    function ownerOf(uint256 _tokenId) external view returns (address);\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n    function approve(address _approved, uint256 _tokenId) external payable;\n    function setApprovalForAll(address _operator, bool _approved) external;\n    function getApproved(uint256 _tokenId) external view returns (address);\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n    interface PRC165 {\n        function supportsInterface(bytes4 interfaceID) external view returns (bool);\n    }\n\n    //optional\n    interface PRC721TokenReceiver {\n        function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\n    }\n    //The metadata extension interface is optional for PRC-721 smart contracts and allows users to query the name of the smart contract as well as the details of the asset represented by the NFT.\n    interface PRC721Metadata {\n        function name() external view returns (string _name);\n        function symbol() external view returns (string _symbol);\n        function tokenURI(uint256 _tokenId) external view returns (string);\n    }\n    //The enumeration extension is optional for PRC-721 smart contracts and allows a user's smart contract to publish its full list of NFTs and make them visible.\n    interface PRC721Enumerable {\n        function totalSupply() external view returns (uint256);\n        function tokenByIndex(uint256 _index) external view returns (uint256);\n        function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n    }\n}\n")),(0,i.kt)("h4",{id:"required-interfaces"},"Required interfaces"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"balanceOf"),(0,i.kt)("p",{parentName:"li"},"Counts the number of NFTs held by users.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"ownerOf"),(0,i.kt)("p",{parentName:"li"},"Query the holder of the NFT.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"safeTransferFrom"),(0,i.kt)("p",{parentName:"li"},"Transfer ownership of the NFT from one address to another.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"transferFrom"),(0,i.kt)("p",{parentName:"li"},"Transferring NFT ownership, the caller is responsible for confirming that the recipient has the ability to receive NFTs that might otherwise be permanently lost.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"approve"),(0,i.kt)("p",{parentName:"li"},"Authorize a third party to operate an NFT asset.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"setApprovalForAll"),(0,i.kt)("p",{parentName:"li"},"Authorize a third party to operate an NFT asset.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"getApproved"),(0,i.kt)("p",{parentName:"li"},"Get which address management is authorized for a single NFT.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"isApprovedForAll"),(0,i.kt)("p",{parentName:"li"},"Queries whether an address is authorized to manage token by another address.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"supportsInterface"),(0,i.kt)("p",{parentName:"li"},"Queries whether an address is authorized to manage token by another address."))),(0,i.kt)("h4",{id:"optionally--interfaces"},"Optionally  interfaces"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"onERC721Received"),(0,i.kt)("p",{parentName:"li"},"Contracts that need to accept secure transfers must implement the PRC721TokenReceiver interface.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"name"),(0,i.kt)("p",{parentName:"li"},"The name of the contract.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"symbol"),(0,i.kt)("p",{parentName:"li"},"The abbreviated code for the contract.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"tokenURI"),(0,i.kt)("p",{parentName:"li"},'Give the token a Uniform Resource Identifier (URI) that points to a JSON file that conforms to the "PRC721 Metadata JSON Schema", which needs to be assigned a unique URI for each token when minting it.'),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-JSON"},'{\n  "title": "Asset Metadata",\n  "type": "object",\n  "properties": {\n      "name": {\n          "type": "string",\n          "description": "Identifies the asset to which this NFT represents"\n      },\n      "description": {\n          "type": "string",\n          "description": "Describes the asset to which this NFT represents"\n      },\n      "image": {\n          "type": "string",\n          "description": "A URI pointing to a resource with mime type image/* representing the asset to which this NFT represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive."\n      }\n  }\n}\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"totalSupply"),(0,i.kt)("p",{parentName:"li"},"Query the total number of tokens owned by this contract.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"tokenByIndex"),(0,i.kt)("p",{parentName:"li"},"Query token by index.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"tokenOfOwnerByIndex"),(0,i.kt)("p",{parentName:"li"},"Find the user's token based on the index."))),(0,i.kt)("h4",{id:"event"},"Event"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Transfer"),(0,i.kt)("p",{parentName:"li"},"This event is triggered when the ownership of any NFT changes (either way), and a log of ownership change information is recorded on the chain.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Approval"),(0,i.kt)("p",{parentName:"li"},"Triggered when the authorized address of the NFT is changed or confirmed, logging this information on the chain.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"ApprovalForAll"),(0,i.kt)("p",{parentName:"li"},"Triggered when the owner enables or disables the operator (the operator can manage the NFTs held by the owner), logging this information in the chain."))),(0,i.kt)("h3",{id:"example"},"Example"),(0,i.kt)("p",null,"The PRC-721 standard is fully compatible with ERC-721, examples of which can be found ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/0xcert/ethereum-erc721"},"here"),"."),(0,i.kt)("h3",{id:"view"},"View"),(0,i.kt)("p",null,"It can be viewed through PlatON ",(0,i.kt)("a",{parentName:"p",href:"https://scan.PlatON.network/tokens/tokensTranfer/prc721"},"browser")," and also through ",(0,i.kt)("a",{parentName:"p",href:"/docs/en/ATON-user-manual/"},"ATON")," to view the PRC-721 contract transactions."),(0,i.kt)("h3",{id:"deploy"},"Deploy"),(0,i.kt)("p",null,"please refer to ",(0,i.kt)("a",{parentName:"p",href:"/docs/en/Solidity_Dev_Manual#introduction"},"Solidity Contracts Getting Started Manual")),(0,i.kt)("h2",{id:"invoking-functions"},"Invoking functions"),(0,i.kt)("p",null,"Using python as an example."),(0,i.kt)("h4",{id:"installing-python-dependencies"},"Installing python dependencies"),(0,i.kt)("p",null,"Use the following command to install the PlatON python library, Python version 3.7.5+ is recommended:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"pip install client-sdk-python\n")),(0,i.kt)("p",null,"During the installation process, some dependency packages will require c++14 compilation, please download ",(0,i.kt)("a",{parentName:"p",href:"http://go.microsoft.com/fwlink/?LinkId=691126"},"cppbuildtools")," after you see the relevant prompt, use the default value to install it, and then re-execute the pip install command."),(0,i.kt)("h4",{id:"instantiate-the-contract"},"Instantiate the contract"),(0,i.kt)("p",null,"The following is a sample python code."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from client_sdk_python import Web3, HTTPProvider\n\nrpc, chain_id, hrp = \'http://127.0.0.1:6789\', 100, \'lat\'\nw3 = Web3(HTTPProvider(rpc), chain_id=chain_id, hrp_type=hrp)\nabi = [\n  {\n    "inputs": [\n      { "internalType": "string", "name":"_name", "type": "string"}\n      {"internalType": "string", "name":"_symbol", "type": "string"}\n    ],\n    "stateMutability": "nonpayable",\n    "type": "constructor"\n  },\n  {\n    "inputs": [\n      { "internalType": "address", "name": "_to", "type": "address" }\n      {"internalType": "uint256", "name":"_tokenId", "type": "uint256"}, {"internalType": "uint256", "name":"_tokenId", "type": "uint256"},\n      {"internalType": "string", "name":"_uri", "type": "string"}\n    ],\n    "name": "mint",\n    "outputs": [],\n    "stateMutability": "nonpayable",\n    "type": "function"\n  },\n  {\n    "inputs": [{"internalType": "address", "name": "_owner", "type": "address"}],\n    "name": "balanceOf",\n    "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],\n    "stateMutability": "view",\n    "type": "function"\n  },\n  {\n    "inputs": [{"internalType": "uint256", "name": "_tokenId", "type": "uint256"}],\n    "name": "ownerOf",\n    "outputs": [{"internalType": "address", "name": "_owner", "type": "address"}],\n    "stateMutability": "view",\n    "type": "function"\n  },\n  {\n    "inputs": [\n      { "internalType": "address", "name": "_from", "type": "address" }\n      {"internalType": "address", "name":"_to", "type": "address"}, {"internalType": "address", "name":"_to", "type": "address"}, {"internalType": "address", "name":"_to", "type": "address"},\n      {"internalType": "uint256", "name":"_tokenId", "type": "uint256"}, {"internalType": "uint256", "name":"_tokenId", "type": "uint256"}\n    ],\n    "name": "safeTransferFrom",\n    "outputs": [],\n    "stateMutability": "nonpayable",\n    "type": "function"\n  },\n  {\n    "anonymous": false,\n    "inputs": [\n      { "indexed": true, "internalType": "address", "name": "_from", "type": "address" }\n      {"indexed": true, "internalType": "address", "name":"_to", "type": "address"}, "indexed": true, "internalType": "address", "name":"_to", "type": "address"},\n      {"indexed": true, "internalType": "uint256", "name":"_tokenId", "type": "uint256"}\n    ],\n    "name": "Transfer",\n    "type": "event"\n  },\n]\nprc721 = w3.eth.contract(address=\'contract address\', abi=abi)\n# View all functions and events of the contract\nprint([func for func in prc721.functions])\nprint([event for event in prc721.events])\n')),(0,i.kt)("h4",{id:"query-contract-information"},"Query contract information"),(0,i.kt)("p",null,"With balanceOf, ownerOf example, other query methods are similar to this."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# Count the number of NFTs held by users\nprc721.functions.balanceOf('your address').call()\n# Query the holder of NFTs\nprc721.functions.ownerOf('your token id').call()\n")),(0,i.kt)("h4",{id:"sending-contract-transactions"},"Sending contract transactions"),(0,i.kt)("p",null,"Using the safeTransferFrom example, other transaction methods are similar to this."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# Transfer ownership of NFT from one address to another\ntx = {\n    'chainId': w3.chain_id,\n    'nonce': w3.eth.getTransactionCount('your address'),\n    'gas': 4012388,\n    'value': 0,\n    'gasPrice': 1000000000,\n}\ntxn = prc721.functions.safeTransferFrom(_from='your address', _to='to address', _tokenId='your token id').buildTransaction(tx)\nsigned_txn = w3.eth.account.signTransaction(txn, private_key='your private key')\ntx_hash = w3.eth.sendRawTransaction(signed_txn.rawTransaction).hex()\nreceipt = w3.eth.waitForTransactionReceipt(tx_hash)\n")),(0,i.kt)("h4",{id:"get-contract-events"},"Get contract events"),(0,i.kt)("p",null,"Using the safeTransferFrom transaction event example, other event fetching methods are similar to this."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"events = prc721.events.Transfer().processReceipt(receiveipt)\n")),(0,i.kt)("h3",{id:"upload-metadata-to-ipfs-network"},"Upload Metadata to IPFS network"),(0,i.kt)("p",null,"Metadata is the metadata of NFT tokens in order to display more detailed information about NFT assets, stored under the chain, generally the issuance of an NFT token will specify a URI path to the Metadata data of this token."),(0,i.kt)("h4",{id:"1-install-ipfs"},"1. Install IPFS"),(0,i.kt)("p",null,"Refer to the ",(0,i.kt)("a",{parentName:"p",href:"https://docs.ipfs.io/install/command-line/"},"IPFS")," installation instructions to install and start."),(0,i.kt)("h4",{id:"2-adding-files-to-ipfs"},"2. Adding files to ipfs"),(0,i.kt)("p",null,"Prepare an image, name it PlatON.jpeg, and upload it to the ipfs node"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ ipfs add PlatON.jpeg\nadd QmZtmD2qt6fJot32nabSP3CUjicnypEBz7bHVDhPQt9aAy PlatON.jpeg\n//QmZtmD2qt6fJot32nabSP3CUjicnypEBz7bHVDhPQt9aAy is the unique ID of the file, generated after adding it to ipfs\n")),(0,i.kt)("p",null,"If you open the link to the image in your browser and see the image, it means that the image was successfully downloaded:\n",(0,i.kt)("a",{parentName:"p",href:"https://ipfs.io/ipfs/QmZtmD2qt6fJot32nabSP3CUjicnypEBz7bHVDhPQt9aAy?filename=PlatON.jpeg"},"https://ipfs.io/ipfs/QmZtmD2qt6fJot32nabSP3CUjicnypEBz7bHVDhPQt9aAy?filename=PlatON.jpeg")),(0,i.kt)("p",null,"With the image link above, you can use it to construct the metadata for NFT."),(0,i.kt)("p",null,"First, follow the instructions in the PRC-721 document metadata to create a json file named PlatON.json:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'{\n    "name": "PlatON.jpg",\n    "author": "PlatON",\n    "description": "use for prc721",\n    "image": "https://ipfs.io/ipfs/QmZtmD2qt6fJot32nabSP3CUjicnypEBz7bHVDhPQt9aAy?filename=PlatON.jpeg"\n}\n')),(0,i.kt)("p",null,"Upload to the ipfs node:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ ipfs add PlatON.json\nadded QmQXqTVCb1w7CmdsYxHWR1T1qyaCHHgWwiPmoZDcQL39Px PlatON.json\n")),(0,i.kt)("p",null,"Open the uri of the metadata file in your browser:\n",(0,i.kt)("a",{parentName:"p",href:"https://ipfs.io/ipfs/QmQXqTVCb1w7CmdsYxHWR1T1qyaCHHgWwiPmoZDcQL39Px?filename=PlatON.json"},"https://ipfs.io/ipfs/QmQXqTVCb1w7CmdsYxHWR1T1qyaCHHgWwiPmoZDcQL39Px?filename=PlatON.json")),(0,i.kt)("p",null,"Above, the upload is complete."))}u.isMDXComponent=!0}}]);