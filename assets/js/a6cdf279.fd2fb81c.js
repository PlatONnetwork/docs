"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3606],{3905:function(e,t,a){a.d(t,{Zo:function(){return s},kt:function(){return N}});var n=a(7294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function p(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var m=n.createContext({}),o=function(e){var t=n.useContext(m),a=t;return e&&(a="function"==typeof e?e(t):p(p({},t),e)),a},s=function(e){var t=o(e.components);return n.createElement(m.Provider,{value:t},e.children)},k={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,r=e.originalType,m=e.parentName,s=i(e,["components","mdxType","originalType","parentName"]),u=o(a),N=l,d=u["".concat(m,".").concat(N)]||u[N]||k[N]||r;return a?n.createElement(d,p(p({ref:t},s),{},{components:a})):n.createElement(d,p({ref:t},s))}));function N(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=a.length,p=new Array(r);p[0]=u;var i={};for(var m in t)hasOwnProperty.call(t,m)&&(i[m]=t[m]);i.originalType=e,i.mdxType="string"==typeof e?e:l,p[1]=i;for(var o=2;o<r;o++)p[o]=a[o];return n.createElement.apply(null,p)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},9613:function(e,t,a){a.r(t),a.d(t,{contentTitle:function(){return m},default:function(){return u},frontMatter:function(){return i},metadata:function(){return o},toc:function(){return s}});var n=a(7462),l=a(3366),r=(a(7294),a(3905)),p=["components"],i={id:"Wasm_Contract_API",title:"Wasm API",sidebar_label:"Wasm API"},m=void 0,o={unversionedId:"Wasm_Contract_API",id:"Wasm_Contract_API",isDocsHomePage:!1,title:"Wasm API",description:"block api",source:"@site/../docs/wasm\u5408\u7ea6API.md",sourceDirName:".",slug:"/Wasm_Contract_API",permalink:"/docs/Wasm_Contract_API",editUrl:"https://github.com/PlatONnetwork/docs/tree/master/docs/wasm\u5408\u7ea6API.md",version:"current",frontMatter:{id:"Wasm_Contract_API",title:"Wasm API",sidebar_label:"Wasm API"},sidebar:"docs",previous:{title:"Best practices",permalink:"/docs/Wasm_Contract_Best_Practice"},next:{title:"Python SDK",permalink:"/docs/Python_SDK"}},s=[{value:"block api",id:"block-api",children:[]},{value:"transaction api",id:"transaction-api",children:[]},{value:"account api",id:"account-api",children:[]},{value:"storage api",id:"storage-api",children:[]},{value:"contract api",id:"contract-api",children:[]},{value:"exception api",id:"exception-api",children:[]},{value:"other api",id:"other-api",children:[]}],k={toc:s};function u(e){var t=e.components,a=(0,l.Z)(e,p);return(0,r.kt)("wrapper",(0,n.Z)({},k,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h3",{id:"block-api"},"block api"),(0,r.kt)("h4",{id:"platon_block_hash"},"platon_block_hash()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"h256 platon::platon_block_hash(int64_t num)\n")),(0,r.kt)("p",null,"Gets the block hash based on the block height."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"num:")," Height of block"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Hash of block")))),(0,r.kt)("h4",{id:"platon_block_number"},"platon_block_number()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"uint64_t platon_block_number()\n")),(0,r.kt)("p",null,"Get the height of the current block"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the height of the current block")))),(0,r.kt)("h4",{id:"platon_coinbase"},"platon_coinbase()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"Address platon::platon_coinbase()\n")),(0,r.kt)("p",null,"Gets the Hash of miner nodes."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Hash of miner nodes")))),(0,r.kt)("h4",{id:"platon_unix_timestamp"},"platon_unix_timestamp()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int64_t platon::platon_unix_timestamp()\n")),(0,r.kt)("p",null,"Get the unix timestamp of the current block."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The unix timestamp of the current block (second)")))),(0,r.kt)("h4",{id:"platon_gas_limit"},"platon_gas_limit()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"uint64_t platon_gas_limit()\n")),(0,r.kt)("p",null,"Get the value of gas price limit"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the value of gas price limit")))),(0,r.kt)("h3",{id:"transaction-api"},"transaction api"),(0,r.kt)("h4",{id:"platon_gas_price"},"platon_gas_price()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"u128 platon::platon_gas_price()\n")),(0,r.kt)("p",null,"Get the value of gas price."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The value of gas price")))),(0,r.kt)("h4",{id:"platon_gas"},"platon_gas()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"uint64_t platon_gas()\n")),(0,r.kt)("p",null,"Get the value of gas"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the value of gas")))),(0,r.kt)("h4",{id:"platon_caller_nonce"},"platon_caller_nonce"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"uint64_t platon_caller_nonce()\n")),(0,r.kt)("p",null,"Get the value of the caller's nonce"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the value of the caller's nonce")))),(0,r.kt)("h4",{id:"platon_call_value"},"platon_call_value()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"u128 platon::platon_call_value()\n")),(0,r.kt)("p",null,"Get the value of the current transaction value field."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The value of the current transaction value field")))),(0,r.kt)("h4",{id:"platon_caller"},"platon_caller()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"Address platon::platon_caller()\n")),(0,r.kt)("p",null,"Get the address of caller."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The address of caller")))),(0,r.kt)("h4",{id:"platon_origin"},"platon_origin()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"Address platon::platon_origin()\n")),(0,r.kt)("p",null,"Get the address of original caller."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The address of original caller")))),(0,r.kt)("h4",{id:"platon_address"},"platon_address()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"Address platon::platon_address()\n")),(0,r.kt)("p",null,"Get the address of contract."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The address of contract")))),(0,r.kt)("h3",{id:"account-api"},"account api"),(0,r.kt)("h4",{id:"make_address-12"},"make_address() 1/2"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template <size_t M> std::pair<Address, bool> make_address(const char (&str)[M])\n")),(0,r.kt)("p",null,"The default address recognized by CDT is the main network address, that is, the address prefix is lat. If you want to recognize the test network address prefix is lax, you need to define the macro TESTNET, and you can put #define TESTNET on the first line of the contract."),(0,r.kt)("p",null,"Converts a c-style string to an address object."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"str\uff1a")," C-style string"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The return value is pair, whose second represents success or failure, and whose first represents an Address of type Address.")))),(0,r.kt)("h4",{id:"make_address-22"},"make_address() 2/2"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"std::pair<Address, bool> make_address(const std::string &str_address)\n")),(0,r.kt)("p",null,"The default address recognized by CDT is the main network address, that is, the address prefix is lat. If you want to recognize the test network address prefix is lax, you need to define the macro TESTNET, and you can put #define TESTNET on the first line of the contract."),(0,r.kt)("p",null,"Converts a string to an address object."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"str\uff1a")," string"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The return value is pair, whose second represents success or failure, and whose first represents an Address of type Address.")))),(0,r.kt)("h4",{id:"platon_balance"},"platon_balance()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"Energon platon::platon_balance(const Address & addr)\n")),(0,r.kt)("p",null,"Get the balance based on the address."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," address"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The balance of the address")))),(0,r.kt)("h4",{id:"platon_transfer"},"platon_transfer()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"bool platon::platon_transfer(const Address &addr, const Energon &amount)\n")),(0,r.kt)("p",null,"Transfer the amount of Energon to address."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," Accounts address"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"amount:")," The amount of Energon"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"true if transfer success, false otherwise")))),(0,r.kt)("h4",{id:"platonenergon-class"},"platon::Energon Class"),(0,r.kt)("p",null,"Energo is a type of currency"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Public Member Functions")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Energon (u128 n)"),"\nConstruct a new Energon.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"const u128 Get () const"),"\nGet amount of Von.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"const bytes Bytes () const"),"\nGet the bytes of value, the bytes use big-end representations.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Energon & Add (const u128 &v)"),"\nAdd amount of Von.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Energon & Add (const Energon &rhs)"),"\nAdd amount of Von.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Energon & operator+= (const Energon &rhs)"),"\nImplement operator +=")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Constructor & Destructor Documentation")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"platon::Energon::Energon(u128 n)"),"\nConstruct a new Energon.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"n:"),"amount of Von"))))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Member Function Documentation")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Energon& platon::Energon::Add(const Energon & rhs)"),"\nAdd amount of Von."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"rhs:"),"Amount of Von"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The reference of Energon"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Energon& platon::Energon::Add(const u128 & v)"),"\nAdd amount of Von."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"v:")," Amount of Von"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The reference of Energon"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"const bytes platon::Energon::Bytes() const")),(0,r.kt)("p",{parentName:"li"},"Get the bytes of value, the bytes use big-end representations."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The bytes of value"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"const u128 platon::Energon::Get() const")),(0,r.kt)("p",{parentName:"li"},"Get amount of Von."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The amount of Von"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Energon& platon::Energon::operator+= ( const Energon & rhs)")),(0,r.kt)("p",{parentName:"li"},"Implement operator +="),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"rhs:")," Energon object"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The reference of Energon")))))))),(0,r.kt)("h4",{id:"platonwhitelist-tablename--class"},"platon::WhiteList< TableName > Class"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<Name::Raw TableName>\nclass platon::WhiteList< TableName >\n")),(0,r.kt)("p",null,"Persist storage whitelist implement."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Template Parameters"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Name:")," Whitelist name, in the same contract, the name should be unique")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Constructor & Destructor Documentation")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName>\nplaton::WhiteList< TableName >::WhiteList ()")),(0,r.kt)("p",{parentName:"li"},"Construct a new whitelist.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"public Member Functions")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"WhiteList ()"),"\nConstruct a new whitelist.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"void Add (const std::string &addr)"),"\nAdd the address to whitelist.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"void Add (const Address &addr)"),"\nAdd the address to whitelist.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"void Delete (const std::string &addr)"),"\nDelete the address from whitelist.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"void Delete (const Address &addr)"),"\nDelete the address from whitelist.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"bool Exists (const std::string &addr)"),"\nWhether the address exists in whitelist.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"bool Exists (const Address &addr)"),"\nWhether the address exists in whitelist.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Member Function Documentation")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName>\nvoid platon::WhiteList< TableName >::Add ( const Address & addr)")),(0,r.kt)("p",{parentName:"li"},"Add the address to whitelist."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," Accounts address"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName>\nvoid platon::WhiteList< TableName >::Add ( const std::string & addr)"),"\nAdd the address to whitelist."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," Accounts address"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName>\nvoid platon::WhiteList< TableName >::Delete ( const Address & addr)"),"\nDelete the address from whitelist."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," Accounts address"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName>\nvoid platon::WhiteList< TableName >::Delete ( const std::string & addr)"),"\nDelete the address from whitelist."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," Accounts address"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName>\nbool platon::WhiteList< TableName >::Exists ( const Address & addr)"),"\nWhether the address exists in whitelist."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," Accounts address"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"true if exists, false otherwise"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName>\nbool platon::WhiteList< TableName >::Exists ( const std::string & addr)"),"\nWhether the address exists in whitelist."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," Accounts address"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"true if exists, false otherwise")))))))),(0,r.kt)("h3",{id:"storage-api"},"storage api"),(0,r.kt)("h4",{id:"platon_set_state"},"platon_set_state()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void platon_set_state(const uint8_t *key, size_t klen, const uint8_t *value, size_t vlen)\n")),(0,r.kt)("p",null,"Set the state object"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"key:")," Key"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Klen:")," The length of key"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value:")," Value"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"vlen:")," The length of value")))),(0,r.kt)("h4",{id:"platon_get_state_length"},"platon_get_state_length()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"size_t platon_get_state_length(const uint8_t *key, size_t klen)\n")),(0,r.kt)("p",null,"Get the length of state object"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters"),"\n*",(0,r.kt)("inlineCode",{parentName:"p"},"key:")," Key"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Klen:")," The length of key"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The length of state object")))),(0,r.kt)("h4",{id:"platon_get_state"},"platon_get_state()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"size_t platon_get_state(const uint8_t *key, size_t klen, uint8_t *value, size_t vlen);\n")),(0,r.kt)("p",null,"Get the state object"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"key:")," Key"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Klen:")," The length of key"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value:")," Value"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"vlen:")," The length of value"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The length of value")))),(0,r.kt)("h4",{id:"platonstoragetype-storagename-t--class-template"},"platon::StorageType< StorageName, T > Class Template"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<Name::Raw StorageName, typename T>\nclass platon::StorageType< StorageName, T >\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Template Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"StorageName:")," Element value name, in the same contract, the name needs to be unique"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"T:")," Element type"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Public Member Functions")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"StorageType ()"),"\nConstruct a new Storage Type object")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"StorageType (const T &d)"),"\nConstruct a new Storage Type object")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"StorageType (const StorageType< StorageName, T > &)=delete"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"StorageType (const StorageType< StorageName, T > &&)=delete"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"~StorageType ()"),"\nDestroy the Storage Type object. Refresh to blockchain.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T & operator= (const T &t)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> bool operator== (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> bool operator!= (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> bool operator< (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> bool operator>= (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> bool operator<= (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> bool operator> (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> T & operator^= (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> T  operator^ (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> T & operator|= (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> T  operator| (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> T & operator&= (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> T  operator& (const P &t) const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T  operator~ () const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T & operator<< (int offset)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T & operator>> (int offset)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T & operator++ ()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T  operator++ (int)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T & operator[] (int i)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> T & operator+= (const P &p)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<typename P> T & operator-= (const P &p)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T & operator* ()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T *  operator-> ()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"operator bool () const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T  get () const"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"T & self ()")))))),(0,r.kt)("h4",{id:"platondbarray-tablename-key-n--class-template"},"platon::db::Array< TableName, Key, N > Class Template"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<Name::Raw TableName, typename Key, unsigned N>\nclass platon::db::Array< TableName, Key, N >\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Classes")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"class const_iterator\nConstant iterator."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"class const_reverse_iterator\nConstant reverse iterator."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"class iterator\nIterator."))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Public Types")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"typedef std::reverse_iterator< iterator >  reverse_iterator")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Public Member Functions")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Array ()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Array (const Array< TableName, Key, N > &)=delete"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Array (const Array< TableName, Key, N > &&)=delete"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Array< TableName, Key, N > & operator= (const Array< TableName, Key, N > &)=delete"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"~Array ()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"iterator begin ()"),"\niterator start position")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"iterator end ()"),"\niterator end position")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"reverse_iterator rbegin ()"),"\nReverse iterator start position.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"reverse_iterator rend ()"),"\nReverse iterator end position.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"const_iterator cbegin ()"),"\nConstant iterator start position.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"const_iterator cend ()"),"\nConstant iterator end position.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"const_reverse_iterator crbegin ()"),"\nInverse constant iterator start position.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"const_reverse_iterator crend ()"),"\nInverse constant iterator end position.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Key & at (size_t pos)"),"\nGet the specified position element.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Key & operator[] (size_t pos)"),"\nBracket operator.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"size_t  size ()"),"\narray size")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Key get_const (size_t pos)"),"\nGet the Const object. Do not flush to cache.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"void  set_const (size_t pos, const Key &key)"),"\nSet the Const object, Do not flush to cache.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Static Public Attributes")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},'static const std::string  kType = "__array__"'))))),(0,r.kt)("h4",{id:"platondbmap-tablename-key-value--class-template"},"platon::db::Map< TableName, Key, Value > Class Template"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<Name::Raw TableName, typename Key, typename Value>\nclass platon::db::Map< TableName, Key, Value >\n")),(0,r.kt)("p",null,"Implement map operations, Map templates."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Template Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"TableName:")," The name of the Map, the name of the Map should be unique within each contract."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Key:")," key type"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Value:")," value type")),(0,r.kt)("p",{parentName:"li"},"MapType::Traverse The default is Traverse, when Traverse needs extra data structure to operate, set to NoTraverse when no traversal operation is needed.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Public Member Functions")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Map ()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Map(const Map< TableName, Key, Value > &)=delete"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Map(const Map< TableName, Key, Value > &&)=delete"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Map< TableName, Key, Value > & operator= (const Map< TableName, Key, Value > &)=delete"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"~Map ()"),"\nDestroy the Map object Refresh data to the blockchain.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"bool insert (const Key &k, const Value &v)"),"\nInsert a new key-value pair, Update to cache.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"bool insert_const (const Key &k, const Value &v)"),"\nInsert a new key-value pair that will not be updated to the cache. Suitable for large number of inserts, no updates after insertion.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Value  get_const (const Key &k)"),"\nGet the Const object, will not join the cache.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Value & at (const Key &k)"),"\nGet value, will be added to the cache.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"void  erase (const Key &k)"),"\nDelete key-value pairs.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Value & operator[] (const Key &k)"),"\nBracket operator.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"boolcontains (const Key &key)"),"\nChecks if there is an element with key equivalent to key in the container.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"void  flush ()"),"\nRefresh the modified data in memory to the blockchain.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Static Public Attributes"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},'static const std::string  kType = "__map__"'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Constructor & Destructor Documentation")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value >\nplaton::db::Map< TableName, Key, Value >::Map ()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value >\nplaton::db::Map< TableName, Key, Value >::Map (const Map< TableName, Key, Value > & )"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value >\nplaton::db::Map< TableName, Key, Value >::Map (const Map< TableName, Key, Value > && )"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value >\nplaton::db::Map< TableName, Key, Value >::~Map ()")))))),(0,r.kt)("p",null,"Destroy the Map object Refresh data to the blockchain."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Member Function Documentation")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value >\nValue& platon::db::Map< TableName, Key, Value >::at ( const Key & k )"),"\nGet value, will be added to the cache."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"k:")," Key"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Value&")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'typedef platon::db::Map<"map_str"_n, std::string, std::string> MapStr;\nMapStr map;\nmap.insert("hello", "world");\nassert(map.at["hello"] == "world");\n')))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},""))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value >\nbool platon::db::Map< TableName, Key, Value >::contains ( const Key & key )"),"\nChecks if there is an element with key equivalent to key in the container."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"k:")," Key"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"true if there is such an element, otherwise false.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},' typedef platon::db::Map<"map_str"_n, std::string, std::string> MapStr;\n MapStr map;\n map.["hello"] = "world";\nassert(map.contains("hello"));\n')))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},""))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value >\nvoid platon::db::Map< TableName, Key, Value >::erase ( const Key & k )"),"\nDelete key-value pairs."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"k:")," Key"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'typedef platon::db::Map<"map_str"_n, std::string, std::string> MapStr;\nMapStr map;\nmap.insert("hello", "world");\nmap.erase("hello");\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value >\nvoid platon::db::Map< TableName, Key, Value >::flush ()"),"\nRefresh the modified data in memory to the blockchain.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value >\nValue platon::db::Map< TableName, Key, Value >::get_const ( const Key & k)"),"\nGet the Const object, will not join the cache."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"k:")," Key"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Value")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'typedef platon::db::Map<"map_str"_n, std::string, std::string> MapStr;\nMapStr map;\nmap.insert("hello", "world");\nassert(map.get_const["hello"] == "world");\n')))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},""))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value >\nbool platon::db::Map< TableName, Key, Value >::insert ( const Key & k,\nconst Value & v)"),"\nInsert a new key-value pair, Update to cache."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"k:")," Key"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"v:")," Value"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"true if insert successfully,false otherwise."))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'typedef platon::db::Map<"map_str"_n, std::string, std::string> MapStr;\nMapStr map;\nmap.insert("hello", "world");\nassert(map["hello"] == "world");\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value >\nbool platon::db::Map< TableName, Key, Value >::insert_const ( const Key & k,\nconst Value & v)"),"\nInsert a new key-value pair that will not be updated to the cache. Suitable for large number of inserts, no updates after insertion."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"k:")," Key"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"v:")," Value"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"true if insert successfully,false otherwise."))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'typedef platon::db::Map<"map_str"_n, std::string, std::string> MapStr;\nMapStr map;\nmap.insert_const("hello", "world");\nassert(map["hello"] == "world");\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value >\nMap<TableName, Key, Value>& platon::db::Map< TableName, Key, Value >::operator= ( const Map< TableName, Key, Value > & )"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename Key , typename Value >\nValue& platon::db::Map< TableName, Key, Value >::operator[] ( const Key & k)"),"\nBracket operator."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"k:")," Key"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Value& Get Value")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'typedef platon::db::Map<"map_str"_n, std::string, std::string> MapStr;\nMapStr map;\nmap.["hello"] = "world";\n'))))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Member Data Documentation")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},'template<Name::Raw TableName, typename Key , typename Value >\nconst std::string platon::db::Map< TableName, Key, Value >::kType = "__map__"'))))),(0,r.kt)("h4",{id:"templatenameraw-tablename-typename-t-typename-indices-class-platondbmultiindex-tablename-t-indices-"},"template<Name::Raw TableName, typename T, typename... Indices> class platon::db::MultiIndex< TableName, T, Indices >"),(0,r.kt)("p",null,"MultiIndex supports unique indexes and ordinary indexes. The unique index should be placed first in the parameter. The structure needs to provide the get function corresponding to the index field."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Member Function Documentation")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename T , typename... Indices>const_iterator platon::db::MultiIndex< TableName, T, Indices >::cbegin()"),"\nIterator start position"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"const_iterator"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Example:"))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'  struct Member {\n  std::string name;\n  uint8_t age;\n  uint8_t sex;\n  uint64_t $seq_;\n  std::string Name() const { return name; }\n  uint8_t Age() const { return age; }\n  PLATON_SERIALIZE(Member, (name)(age)(sex))\n};\nMultiIndex<\n  "table"_n, Member,\n  IndexedBy<"index"_n, IndexMemberFun<Member, std::string, &Member::Name,\n                                      IndexType::UniqueIndex>>,\n  IndexedBy<"index2"_n, IndexMemberFun<Member, uint8_t, &Member::Age,\n                                      IndexType::NormalIndex>>>\n  member_table;\nfor (auto it = member_table.cbegin(); it != it_end; ++it){}\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename T , typename... Indices>\nconst_iterator platon::db::MultiIndex< TableName, T, Indices >::cend()"),"\nIterator end position"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"const_iterator"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Example:"))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'  struct Member {\n  std::string name;\n  uint8_t age;\n  uint8_t sex;\n  uint64_t $seq_;\n  std::string Name() const { return name; }\n  uint8_t Age() const { return age; }\n  PLATON_SERIALIZE(Member, (name)(age)(sex))\n};\nMultiIndex<\n  "table"_n, Member,\n  IndexedBy<"index"_n, IndexMemberFun<Member, std::string, &Member::Name,\n                                      IndexType::UniqueIndex>>,\n  IndexedBy<"index2"_n, IndexMemberFun<Member, uint8_t, &Member::Age,\n                                      IndexType::NormalIndex>>>\n  member_table;\nfor (auto it = member_table.cbegin(); it != it_end; ++it){}\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename T , typename... Indices> template<Name::Raw IndexName, typename KEY > size_t platon::db::MultiIndex< TableName, T, Indices >::count(const KEY &key)")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Gets the number of data corresponding to the index value"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Example:"))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'struct Member {\nstd::string name;\nuint8_t age;\nuint8_t sex;\nuint64_t $seq_;\nstd::string Name() const { return name; }\nuint8_t Age() const { return age; }\nPLATON_SERIALIZE(Member, (name)(age)(sex))\n};\nMultiIndex<\n"table"_n, Member,\n  IndexedBy<"index"_n, IndexMemberFun<Member, std::string, &Member::Name,\n                                    IndexType::UniqueIndex>>,\nIndexedBy<"index2"_n, IndexMemberFun<Member, uint8_t, &Member::Age,\n                                      IndexType::NormalIndex>>>\nmember_table;\nauto count = member_table.count<"index2"_n>(uint8_t(10));\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename T , typename... Indices> template<typename Lambda> std::pair<const_iterator, bool> platon::db::MultiIndex< TableName, T, Indices >::emplace(Lambda &constructor)")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"constructor of value"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Returns an iterator that indicates whether the insertion was successful with the bool type. If unique index conflicts, the insertion fails"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Example:"))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'struct Member {\n  std::string name;\n  uint8_t age;\n  uint8_t sex;\n  uint64_t $seq_;\n  std::string Name() const { return name; }\n  uint8_t Age() const { return age; }\n  PLATON_SERIALIZE(Member, (name)(age)(sex))\n};\nMultiIndex<\n  "table"_n, Member,\n  IndexedBy<"index"_n, IndexMemberFun<Member, std::string, &Member::Name,\n                                      IndexType::UniqueIndex>>,\n  IndexedBy<"index2"_n, IndexMemberFun<Member, uint8_t, &Member::Age,\n                                      IndexType::NormalIndex>>>\n  member_table;\nmember_table.emplace([&](auto &m) {\n  m.age = 10;\n  m.name = "hello";\n  m.sex = 1;\n});\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename T , typename... Indices> void platon::db::MultiIndex< TableName, T, Indices >::erase(const_iterator position)"),"\nerase data based on iterator"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"position:")," position of iterator"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Example:"))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'struct Member {\nstd::string name;\nuint8_t age;\nuint8_t sex;\nuint64_t $seq_;\nstd::string Name() const { return name; }\nuint8_t Age() const { return age; }\nPLATON_SERIALIZE(Member, (name)(age)(sex))\n};\nMultiIndex<\n"table"_n, Member,\nIndexedBy<"index"_n, IndexMemberFun<Member, std::string, &Member::Name,\n                                  IndexType::UniqueIndex>>,\nIndexedBy<"index2"_n, IndexMemberFun<Member, uint8_t, &Member::Age,\n                                    IndexType::NormalIndex>>>\nmember_table;\nauto vect_iter = member_table.find<"index"_n>(std::string("use to find data"));\nmember_table.erase(vect_iter[0]);\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename T , typename... Indices> template<Name::Raw IndexName, typename KEY > const_iterator platon::db::MultiIndex< TableName, T, Indices >::find(const KEY & key)"),"\nFind the data, Only a unique index is available."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"key:")," key of index"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the first iterator. cend() if not found."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Example:"))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'struct Member {\nstd::string name;\nuint8_t age;\nuint8_t sex;\nuint64_t $seq_;\nstd::string Name() const { return name; }\nuint8_t Age() const { return age; }\nPLATON_SERIALIZE(Member, (name)(age)(sex))\n};\nMultiIndex<\n"table"_n, Member,\n  IndexedBy<"index"_n, IndexMemberFun<Member, std::string, &Member::Name,\n                                    IndexType::UniqueIndex>>,\nIndexedBy<"index2"_n, IndexMemberFun<Member, uint8_t, &Member::Age,\n                                      IndexType::NormalIndex>>>\nmember_table;\nauto vect_iter = member_table.find<"index"_n>(std::string("use to find data"));\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename T , typename... Indices> template<Name::Raw IndexName>auto platon::db::MultiIndex< TableName, T, Indices >::get_index()"),"\nGets the index object of a non-unique index."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"index object"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Example:"))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'struct Member {\nstd::string name;\nuint8_t age;\nuint8_t sex;\nuint64_t $seq_;\nstd::string Name() const { return name; }\nuint8_t Age() const { return age; }\nPLATON_SERIALIZE(Member, (name)(age)(sex))\n};\nMultiIndex<\n"table"_n, Member,\n  IndexedBy<"index"_n, IndexMemberFun<Member, std::string, &Member::Name,\n                                    IndexType::UniqueIndex>>,\nIndexedBy<"index2"_n, IndexMemberFun<Member, uint8_t, &Member::Age,\n                                      IndexType::NormalIndex>>>\nmember_table;\nauto index = member_table.get_index<"index2"_n>();\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"template<Name::Raw TableName, typename T , typename... Indices> template<typename Lambda >void platon::db::MultiIndex< TableName, T, Indices >::modify(const_iterator position,Lambda && constructor)"),"\nModify data based on iterator, but cannot modify all index-related fields ."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"position:")," position of iterator"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"constructor:")," lambda function that updates the target object"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Example:"))),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'struct Member {\nstd::string name;\nuint8_t age;\nuint8_t sex;\nuint64_t $seq_;\nstd::string Name() const { return name; }\nuint8_t Age() const { return age; }\nPLATON_SERIALIZE(Member, (name)(age)(sex))\n};\nMultiIndex<\n"table"_n, Member,\n  IndexedBy<"index"_n, IndexMemberFun<Member, std::string, &Member::Name,\n                                    IndexType::UniqueIndex>>,\nIndexedBy<"index2"_n, IndexMemberFun<Member, uint8_t, &Member::Age,\n                                      IndexType::NormalIndex>>>\nmember_table;\nmember_table.modify(r.first, [&](auto &m) { m.sex = 15; });\n')))))),(0,r.kt)("h3",{id:"contract-api"},"contract api"),(0,r.kt)("h4",{id:"platon_destroy"},"platon_destroy()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"bool platon::platon_destroy ( const Address & addr)\n")),(0,r.kt)("p",null,"Destory contract."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," Address of the contract"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"true if destroy successfully, false otherwise")))),(0,r.kt)("h4",{id:"platon_migrate_contract"},"platon_migrate_contract()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename value_type , typename gas_type >\nbool platon::platon_migrate_contract ( Address & addr,\nconst bytes & init_args,\nvalue_type  value,\ngas_type  gas)\n")),(0,r.kt)("p",null,"Migrate contract."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr:")," The address of new contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"init_args:")," The input arguments"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value:")," Transfer amount"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"gas:")," Pay amount of gas for this transaction"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"true if migration successfully, false otherwise")))),(0,r.kt)("h4",{id:"cross_call_args"},"cross_call_args()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename... Args>\nbytes platon::cross_call_args ( const std::string & method,\nconst Args &...  args)  \n")),(0,r.kt)("p",null,"Construct the Parameters of the call across contracts."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"method:")," The method name of the invoked contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"args:")," The Parameters corresponding to the contract method"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Parameter byte array")))),(0,r.kt)("h4",{id:"platon_call"},"platon_call()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template <typename value_type, typename gas_type, typename... Args>\ninline bool platon_call(const Address &addr, const value_type &value,\nconst gas_type &gas, const std::string &method,\nconst Args &... args)\n")),(0,r.kt)("p",null,"Cross-contract call without return value."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr\uff1a"),"The contract address to be invoked"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value\uff1a"),"The amount transferred to the contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"gas\uff1a"),"The called contract method estimates the gas consumed"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"method\uff1a"),"The method name of the invoked contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"args\uff1a"),"The Parameters corresponding to the contract method"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Call success or failure"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'auto address_pair =make_address("lax10jc0t4ndqarj4q6ujl3g3ycmufgc77epxg02lt");\nbool result = platon_call(address_pair.first, uint32_t(100), uint32_t(100), "add", 1,2,3);\nif(!result){\n  platon_throw("cross call fail");\n}\n')))),(0,r.kt)("h4",{id:"platon_call_with_return_value"},"platon_call_with_return_value()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template <typename return_type, typename value_type, typename gas_type, typename... Args>\ninline auto platon_call_with_return_value(const Address &addr,\nconst value_type &value,\nconst gas_type &gas,\nconst std::string &method,\nconst Args &... args)\n")),(0,r.kt)("p",null,"Cross-contract call with return value."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr\uff1a"),"The contract address to be invoked"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value\uff1a"),"The amount transferred to the contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"gas\uff1a"),"The called contract method estimates the gas consumed"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"method\uff1a"),"The method name of the invoked contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"args\uff1a"),"The Parameters corresponding to the contract method"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns"),"\n")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Return value and call success or failure\n")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'auto address_pair =make_address("lax10jc0t4ndqarj4q6ujl3g3ycmufgc77epxg02lt"); \nauto result = platon_call_with_return_value<int>(address_pair.first, uint32_t(100), uint32_t(100), "add", 1,2,3);\nif(!result.second){\n platon_throw("cross call fail");\n}\n')))),(0,r.kt)("h4",{id:"platon_delegate_call"},"platon_delegate_call()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template <typename gas_type, typename... Args>\ninline bool platon_delegate_call(const Address &addr, const gas_type &gas,\nconst std::string &method,\nconst Args &... args) \n")),(0,r.kt)("p",null,"Cross-contract proxy call without return value."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr\uff1a"),"The contract address to be invoked"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"gas\uff1a"),"The called contract method estimates the gas consumed"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"method\uff1a"),"The method name of the invoked contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"args\uff1a"),"The Parameters corresponding to the contract method"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Call success or failure"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},' auto address_pair =make_address("lax10jc0t4ndqarj4q6ujl3g3ycmufgc77epxg02lt");\n bool result = platon_delegate_call(address_pair.first, uint32_t(100), uint32_t(100), "add", 1,2,3);\n if(!result){\n   platon_throw("cross call fail");\n }\n')))),(0,r.kt)("h4",{id:"platon_delegate_call_with_return_value"},"platon_delegate_call_with_return_value()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template <typename return_type, typename gas_type, typename... Args>\ninline auto platon_delegate_call_with_return_value(const Address &addr,\nconst gas_type &gas,\nconst std::string &method,\nconst Args &... args) \n")),(0,r.kt)("p",null,"Cross-contract proxy call with return value."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addr\uff1a"),"The contract address to be invoked"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"gas\uff1a"),"The called contract method estimates the gas consumed"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"method\uff1a"),"The method name of the invoked contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"args\uff1a"),"The Parameters corresponding to the contract method"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Return value and call success or failure"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'auto address_pair = make_address("lax10jc0t4ndqarj4q6ujl3g3ycmufgc77epxg02lt"); \nauto result = platon_delegate_call_with_return_value<int>(address_pair.first, uint32_t(100), "add", 1,2,3);\nif(!result.secnod){\n  platon_throw("cross call fail");\n}\n')))),(0,r.kt)("h4",{id:"get_call_output"},"get_call_output()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename T >\nvoid platon::get_call_output ( T & t)\n")),(0,r.kt)("p",null,"Gets the return value of calling contract methods across contracts."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Template Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"T:")," The output value type"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"t:")," The value returned by the contract method")))),(0,r.kt)("h4",{id:"platon_event"},"platon_event"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void platon_event(const uint8_t *topic, size_t topic_len, const uint8_t *args,\n                  size_t args_len);\n")),(0,r.kt)("p",null,"Post event to VM"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"topic:")," The topic of event"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"topic_len:")," The length of topic"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"args:")," The arguments"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"args_len:")," The length of arguments")))),(0,r.kt)("h3",{id:"exception-api"},"exception api"),(0,r.kt)("h4",{id:"platon_panic"},"platon_panic"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void platon_panic(void);\n")),(0,r.kt)("p",null,"Terminate transaction, deduct all gas given by transaction"),(0,r.kt)("h4",{id:"platon_revert"},"platon_revert"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void platon_revert(void);\n")),(0,r.kt)("p",null,"Terminate the transaction and deduct the gas consumed"),(0,r.kt)("h3",{id:"other-api"},"other api"),(0,r.kt)("h4",{id:"platon_sha3"},"platon_sha3()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"h256 platon::platon_sha3 ( const bytes & data )\n")),(0,r.kt)("p",null,"Sh3 algorithm."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"data:")," Binary data"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The Hash of the data")))),(0,r.kt)("hr",null))}u.isMDXComponent=!0}}]);